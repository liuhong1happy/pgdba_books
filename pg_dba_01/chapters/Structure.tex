\chapter{Install structure}\label{cha:INSTALLSTRUCT}
Depending on the installation method, the install structure can be into a single directory or in multiple 
folders.\newline

The install from source creates into the target directory four subfolders.

\begin{itemize}
 \item \textbf{bin} is the location for PostgreSQL's binaries
 \item \textbf{include} contains the server's header files
 \item \textbf{lib} is the location where to put the shared libraries
 \item \textbf{share} is where the example files and the extension configurations are stored
\end{itemize}


The packaged install spreads the binaries and the libraries in different folders with the name organised by 
major version. For example the 9.4 installation will put the binaries into /usr/lib/postgresql/9.4/bin and 
the libraries in /usr/lib/postgresql/9.4/lib. The extensions and the contributed modules are installed into 
the folder /usr/share/postgresql/9.4. The debian package also ships with wrappers stored in the directory 
/usr/bin/. In particular the symbolic link psql ponts the perl script \newline
/usr/lib/share/postgresql-common/pg\_wrapper which calls a specific PostgreSQL client version the cluster 
using the data stored into the files ~/.postgresqlrc or into \newline 
/etc/postgresql-common/user\_clusters.\newline

Whether is the installation method, PostgreSQL binaries can be grouped in two categories, the core 
programs and the additional modules. The latter are a collection of wrappers and contributed 
modules for improving the PostgreSQL's functionality. 

\section{The core binaries}

\subsection{postgres}\index{postgres}
\label{sec:POSTGRES}
This is the PostgreSQL's main process. The program can be started on the command line or using the pg\_ctl 
utility. The second method is to be preferred because gives a simple way to control the postgres 
main process. The command line is required when the database won't start because of the risk of the 
XID wraparound failure\index{XID wraparound failure}. 

\subsection{pg\_ctl}\index{pg\_ctl}
\label{sub:PGCTL}
This utility is the simplest way for managing a PostgreSQL cluster. The program read the postgres 
pid from the cluster's data area and sends the os signals to the main server process according to the 
command shipped on the command line. It's also possible to send custom signals to the running 
instance. The pg\_ctl The supported operations are the following.

\begin{itemize}
 \item \textbf{init[db]} initialises a directory as PostgreSQL data area
 \item \textbf{start} starts a PostgreSQL instance
 \item \textbf{stop} shutdowns a PostgreSQL instance
 \item \textbf{reload} reloads the configuration's files
 \item \textbf{status} checks the PostgreSQL instance running status
 \item \textbf{promote} promotes a standby server 
 \item \textbf{kill} sends a custom signal to the running instance
\end{itemize}

In \ref{cha:MANAGING} we'll se how to manage the cluster.

\subsection{initdb}\index{initdb}
Is the binary which initialises the PostgreSQL data area. The directory to initialise must 
be empty. Various options can be specified on the command line, like the character enconding or the 
collation order. 

\subsection{psql}\index{psql}
This is the PostgreSQL command line client. The client it looks very essential, however is one of 
the most flexible tools available to interact with the server and the only choice when working on 
the command line.

\subsection{pg\_dump}\index{pg\_dump}
\label{sub:PGDUMP}
This is the binary dedicated to the backup. Can produce consistent backups in various formats. The 
usage is described shown in \ref{cha:BACKUP}.

\subsection{pg\_restore}\index{pg\_restore}
This program is used to restore a database reading a binary dump like the custom or directory 
format. It's able to run the restore in multiple jobs in order to speed up the process. The usage 
is described in \ref{cha:RESTORE}

\subsection{pg\_controldata}\index{pg\_controldata}\label{sub:PGCONTROLDATA}
This program can query the cluster's control file where PostgreSQLstores critical informations for 
the cluster activity and reliability. 

\subsection{pg\_resetxlog}\index{pg\_resetxlog}
If a WAL file becomes corrupted the cluster cannot perform a crash recovery. This lead to a not 
startable cluster in case of system crash. In this catastrophic scenario there's still a 
possibility to start the cluster. Using pg\_resetxlog the cluster is cleared of any WAL file, the  
control file is initialised from scratch and the transaction's count is restarted.\newline

The \textit{tabula rasa} have a cost indeed. The cluster lose any reference between the 
transactions progression and the data files. The physical integrity is lost and any attempt to run 
queries which write data will results in corruption.\newline 

The PostgreSQL's documentation is absolutely clear on this point.

\begin{verbatim}

After running pg_resetxlog the database must start without user access, 
the entire content must be dumped, the data directory must be dropped and recreated 
from scratch using initdb and then the dump file can be restored using psql or pg_restore
\end{verbatim}

\section{Wrappers and contributed modules}
The second group of binaries is composed by the contributions and the wrappers. The 
contributed modules add functions otherwise not available. The wrappers add command line 
functions already present as SQL statements. Someone will notice the lack of HA specific binaries 
like pg\_receivexlog and pg\_archivecleanup. They have been purposely skipped because beyond the 
scope of this book.

\subsection{The create and drop utilities}
The  binaries with the prefix create and drop like, createdb createlang createuser and dropdb, 
droplang, dropuser, are wrappers for the corresponding SQL functions. Each program performs the 
creation and the drop action on the corresponding named object. For example createdb adds a 
database to the cluster and dropdb will drop the specified database. 

\subsection{clusterdb}\index{clusterdb}
This program performs a database wide cluster on the tables with clustered indices. 
The binary can run on a single table specified on the command line. In \ref{sec:VACFULL} we'll 
take a look to CLUSTER and VACUUM FULL.

\subsection{reindexdb}\index{reindexdb}
The command does a database wide reindex. It's possible to run the command just on a table or index 
passing the relation's name on the command line. In \ref{sec:REINDEX} we'll take a good look to 
the index management.

\subsection{vacuumdb}\index{vacuumdb}
This binary is a wrapper for the VACUUM \index{VACUUM} SQL command. This is the most important 
maintenance task and shouldn't be ignored. The program performs a database wide VACUUM if executed 
without a target relation. Alongside with a common vacuum it's possible to have the usage 
statistics updated on the same time.

\subsection{vacuumlo}\index{vacuumlo}
This binary will remove the orphaned large objects from the pg\_largeobject system table. The 
pg\_largeobject is used to store the binary objects bigger than the limit of 1GB imposed by the 
bytea data type. The limit for a large object it is 2 GB since the version 9.2. From the version 
9.3 the limit was increased to 4 TB. 

\section{Debian's specific utilities}
Finally let's take a look to the debian's specific utilities. They are a collection of perl scripts 
used to simplify the cluster's management. Their install location is /usr/bin mostly like symbolic 
links to the actual executable. We already mentioned one of them in the chapter's introduction, the 
psql pointing to the pg\_wrapper PERL script.

\subsection{pg\_createcluster}\index{pg\_createcluster}
This script adds a new PostgreSQL cluster with the given major version, if installed, and the 
given name. The script puts all the configurations in /etc/postgresql. Each major version have a 
dedicated directory under which is present a group of directories with the cluster's specific 
configuration files. If not specified the data directory is created into the folder 
/var/lib/postgresql. It's also possible to specify the options for initd.

\subsection{pg\_dropcluster}\index{pg\_dropcluster}
The program delete a PostgreSQL cluster created previously with pg\_createcluster. The 
program will not drop a running cluster. If the dropped cluster have any tablespace those must be 
manually removed after the drop as the program doesn't follow the symbolic links.

\subsection{pg\_lscluster}\index{pg\_lscluster}
Lists the clusters created with pg\_createcluster.

\subsection{pg\_ctlcluster}\index{pg\_ctlcluster}
\label{sub:PGCTLDEB}
The program manages the cluster in a similar way pg\_ctl does. 
Before the version 9.2 this wrapper had a dangerous behaviour for the shutdown. The script did not 
offered a flexible way to provide the shutdown mode. More informations about the shutdown 
sequence are in \ref{sec:SHUTDOWN_SEQ}. 
Without any option pg\_ctlcluster performs a smart shutdown mode.
The --force option tells the script to try a \textit{fast} shutdown mode. Unfortunately if the 
database doesn't shutdown in a \textit{reasonable time} the script performs an \textit{immediate} 
shutdown. After another short wait, if the the instance is still up the script sends a 
\textit{kill -9} to the postgres process. Because this kind of actions can result in data loss  
they should be made manually by the DBA. It's better to avoid the shutdown using pg\_ctlcluster.
